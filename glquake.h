/*
Copyright (C) 1996-1997 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

*/
// disable data conversion warnings

#pragma warning(disable : 4244)     // MIPS
#pragma warning(disable : 4136)     // X86
#pragma warning(disable : 4051)     // ALPHA
  
#ifdef _WIN32
#include <windows.h>
#endif
#if defined (__APPLE__) || defined (MACOSX)
#include <OpenGL/gl.h>
#include <OpenGL/glu.h>
#include <OpenGL/glext.h>
#else
#include <GL/gl.h>
#include <GL/glu.h>
#endif /* __APPLE__ ||ÊMACOSX */

/* use the correct dynamic function address binder */  
#if defined (SDL)
#define SAFE_GET_PROC( func, type, name)     \
   func = (type) SDL_GL_GetProcAddress (name)
#elif defined (__glx__)
#define SAFE_GET_PROC( func, type, name)     \
   func = (type) glXGetProcAddressARB (name)
#else
#define SAFE_GET_PROC( func, type, name)     \
   func = (type) wglGetProcAddress(name);   \
   if (!func) Sys_Error("Could not get address for %s\n", name)
#endif


// - DC -
#if defined (SDL)
#if defined(__FreeBSD__)
#include <SDL11/SDL_opengl.h>
#else 
#include <SDL/SDL_opengl.h>
#endif
#endif

#if defined (__glx__)
#include <GL/glx.h>
#endif

void GL_checkerror(char *file, int line);

#define GL_DEBUG

#if defined(GL_DEBUG)

#define checkerror() GL_checkerror(__FILE__, __LINE__)

#else

#define checkerror() do { } while(0)

#endif

void GL_BeginRendering (int *x, int *y, int *width, int *height);
void GL_EndRendering (void);


#ifdef _WIN32
// Function prototypes for the Texture Object Extension routines
typedef GLboolean (APIENTRY *ARETEXRESFUNCPTR)(GLsizei, const GLuint *,
                    const GLboolean *);
typedef void (APIENTRY *BINDTEXFUNCPTR)(GLenum, GLuint);
typedef void (APIENTRY *DELTEXFUNCPTR)(GLsizei, const GLuint *);
typedef void (APIENTRY *GENTEXFUNCPTR)(GLsizei, GLuint *);
typedef GLboolean (APIENTRY *ISTEXFUNCPTR)(GLuint);
typedef void (APIENTRY *PRIORTEXFUNCPTR)(GLsizei, const GLuint *,
                    const GLclampf *);
typedef void (APIENTRY *TEXSUBIMAGEPTR)(int, int, int, int, int, int, int, int, void *);

extern	BINDTEXFUNCPTR bindTexFunc;
extern	DELTEXFUNCPTR delTexFunc;
extern	TEXSUBIMAGEPTR TexSubImage2DFunc;
#endif

extern	int texture_extension_number;
extern	int		texture_mode;
extern	int	glow_texture_object;	//PENTA: gl texture object of the glow texture
extern	int normcube_texture_object;//PENTA: gl texture object of the normalization cubemap 
extern	int halo_texture_object;	//PENTA: Halo light texture
extern  int	atten1d_texture_object;
extern  int	atten2d_texture_object;
extern  int	atten3d_texture_object;
extern	float	gldepthmin, gldepthmax;

void GL_Upload32 (unsigned *data, int width, int height,  qboolean mipmap, qboolean alpha);
void GL_Upload8 (byte *data,char *identifier, int width, int height,  qboolean mipmap, qboolean alpha, qboolean bump);
//int GL_LoadTexture (char *identifier, int width, int height, byte *data, qboolean mipmap, qboolean alpha, qboolean bump);
int GL_FindTexture (char *identifier);

typedef struct
{
	float	x, y, z;
	float	s, t;
	float	r, g, b;
} glvert_t;

extern glvert_t glv;

extern	int glx, gly, glwidth, glheight;

#ifdef _WIN32
extern	PROC glArrayElementEXT;
extern	PROC glColorPointerEXT;
extern	PROC glTexturePointerEXT;
extern	PROC glVertexPointerEXT;
#endif

// r_local.h -- private refresh defs

#define ALIAS_BASE_SIZE_RATIO		(1.0 / 11.0)
					// normalizing factor so player model works out to about
					//  1 pixel per triangle
#define	MAX_LBM_HEIGHT		480

#define TILE_SIZE		128		// size of textures generated by R_GenTiledSurf

#define SKYSHIFT		7
#define	SKYSIZE			(1 << SKYSHIFT)
#define SKYMASK			(SKYSIZE - 1)

#define BACKFACE_EPSILON	0.01

#ifndef M_PI_F
#define M_PI_F 3.14159265358979323846f
#endif


void R_TimeRefresh_f (void);
void R_ReadPointFile_f (void);
/*
typedef struct surfcache_s
{
	struct surfcache_s	*next;
	struct surfcache_s 	**owner;		// NULL is an empty chunk of memory
	int					lightadj[MAXLIGHTMAPS]; // checked for strobe flush
	int					dlight;
	int					size;		// including header
	unsigned			width;
	unsigned			height;		// DEBUG only needed for debug
	float				mipscale;
	struct texture_s	*texture;	// checked for animating textures
	byte				data[4];	// width*height elements
} surfcache_t;


typedef struct
{
	pixel_t		*surfdat;	// destination for generated surface
	int			rowbytes;	// destination logical width in bytes
	msurface_t	*surf;		// description for surface to generate
	fixed8_t	lightadj[MAXLIGHTMAPS];
							// adjust for lightmap levels for dynamic lighting
	texture_t	*texture;	// corrected for animating textures
	int			surfmip;	// mipmapped ratio of surface texels / world pixels
	int			surfwidth;	// in mipmapped texels
	int			surfheight;	// in mipmapped texels
} drawsurf_t;
*/

typedef enum {
	pt_static, pt_grav, pt_slowgrav, pt_fire, pt_explode, pt_explode2, pt_blob, pt_blob2
} ptype_t;

typedef enum {
	pb_add, pb_subtract
} pblend_t;


typedef enum {
	emt_box
} emtype_t;

typedef enum {
	align_view, align_vel, align_surf
} align_t;

typedef struct ParticleEffect_s {
	char name[64];
	vec3_t emmiterParams1, emmiterParams2; //mins maxs of emmiter box
	emtype_t emmiterType; //currently only box is supported
	vec3_t startcolormin, startcolormax, endcolormin, endcolormax;
	vec3_t velocitymin, velocitymax; //min max velocity
	float	lifemin, lifemax; //min max life
	int	movetype; //how it moves (gravity/collision...)
	vec3_t	gravity;
	float	rotmin, rotmax;//rotaiton speed
	float	growmin, growmax;//scale speed (make second smaller to shrink)
	float	sizemin, sizemax;//scale speed (make second smaller to shrink)
	vec3_t	drag; //drag of particle (how fast it looses it's speed)
	int	srcblend, dstblend; // gl enums for blend modes
	int	numbounces; //number of bounces before particle is deleted
	int	texture; //gl object of the texture	
	align_t	align;//particle is aligned with its velocity
	float	velscale;
	struct ParticleEffect_s *spawn; //particle effect to spawn on hit
	struct ParticleEffect_s *next;
} ParticleEffect_t;

// !!! if this is changed, it must be changed in d_ifacea.h too !!!
typedef struct particle_s
{
// driver-usable fields
	vec3_t		org;
	vec3_t		color;
// drivers never touch the following fields
	struct particle_s	*next;
	vec3_t		vel;
        //float		ramp;
	float		die, lifetime;
        //ptype_t		type;
//PENTA: Nicer particles (tm)
	int			texture; //texture object of particle
	int			numbounces; //number of bounces left before deletion set to zero for no bounce
	float		rot;
	float		rspeed;
	float		size;
	float		growspeed;
	qboolean	velaligned;
	//pblend_t	blendfunc;
	vec3_t		startcolor, endcolor;
	int			srcblend, dstblend;
	vec3_t		gravity;
	vec3_t		drag;
	float		velscale;
	ParticleEffect_t *spawn; 
} particle_t;

typedef enum {
	dt_blood
} dtype_t;

#define MAX_DECAL_VERTICES 128
#define MAX_DECAL_TRIANGLES 64
//PENTA: Decals
typedef struct decal_s
{
	vec3_t		origin;
	vec3_t		normal;
	vec3_t		tangent;
	float		radius;

	float		color[4], startcolor[4], endcolor[4];
	struct decal_s	*next;
	float		die;
	float		lifetime;
	dtype_t		type;
	int			texture; //texture object of particle
	int			srcblend;
	int			dstblend;

	//geometry of decail
	int	vertexCount, triangleCount;
	vec3_t		vertexArray[MAX_DECAL_VERTICES];
	float		texcoordArray[MAX_DECAL_VERTICES][2];
	int			triangleArray[MAX_DECAL_TRIANGLES][3];
} decal_t;

void R_SpawnDecal(vec3_t center, vec3_t normal, vec3_t tangent, ParticleEffect_t *effect);
float RandomMinMax(float min, float max);

//====================================================


extern	entity_t	r_worldentity;
extern	qboolean	r_cache_thrash;		// compatability
extern	vec3_t		modelorg, r_entorigin;
extern	entity_t	*currententity;
extern	int			r_visframecount;	// ??? what difs?
extern	int			r_framecount;
extern	int			r_lightTimestamp;//PENTA: we need this in different files
extern	mplane_t	frustum[4];
extern	int		c_brush_polys, c_alias_polys;


//
// view origin
//
extern	vec3_t	vup;
extern	vec3_t	vpn;
extern	vec3_t	vright;
extern	vec3_t	r_origin;

//
// screen size info
//
extern	refdef_t	r_refdef;
extern	mleaf_t		*r_viewleaf, *r_oldviewleaf;
extern	int		d_lightstylevalue[256];	// 8.8 fraction of base light value

extern	qboolean	envmap;
extern	int	currenttexture;
extern	int	cnttextures[16];
extern	int	particletexture;
extern	int	particletexture_smoke;
extern	int	particletexture_glow;
extern	int	particletexture_glow2;
extern	int	particletexture_tele;
extern	int	particletexture_blood;
extern	int	particletexture_dirblood;
extern	int	playertextures;
extern	int	gl_filter_min;
extern	int	gl_filter_max;

extern	int	skyshadernum;		// index in cl.loadmodel, not gl texture object

extern	cvar_t	r_norefresh;
extern	cvar_t	cg_showentities;
extern	cvar_t	r_drawworld;
extern	cvar_t	cg_showviewmodel;
extern	cvar_t	r_waterwarp;
extern	cvar_t	r_fullbright;
extern	cvar_t	r_lightmap;
extern	cvar_t	r_mirroralpha;
extern	cvar_t	r_wateralpha;
extern	cvar_t	r_novis;
extern	cvar_t	r_noareaportal;

extern	cvar_t	gl_clear;
extern	cvar_t	gl_poly;
//extern	cvar_t	gl_texsort;
extern	cvar_t	gl_polyblend;

extern	int		gl_lightmap_format;
extern	int		gl_solid_format;
extern	int		gl_alpha_format;

extern	cvar_t	gl_max_size;

extern  cvar_t	gl_calcdepth;

extern  cvar_t	sh_lightmapbright; //PENTA:
extern  cvar_t	sh_visiblevolumes;
extern  cvar_t  sh_entityshadows;
extern  cvar_t  sh_meshshadows;
extern  cvar_t  sh_worldshadows;
extern  cvar_t  sh_showlightsciss;
extern  cvar_t  sh_occlusiontest;
extern  cvar_t  sh_showlightvolume;
extern  cvar_t  sh_glows;
extern	cvar_t  cg_showfps;	// set for running times - muff
extern	cvar_t  sh_debuginfo;
extern	cvar_t	sh_norevis; //PENTA: no recalculating the vis for light positions
extern	cvar_t	sh_nosvbsp; //PENTA: no shadow bsp
extern	cvar_t	sh_noeclip; //PENTA: no entity/leaf clipping for shadows
extern  cvar_t  sh_infinitevolumes;//PENTA:
extern  cvar_t  sh_noscissor;
extern	cvar_t	sh_nocleversave;
extern	cvar_t	sh_bumpmaps;//PENTA: enable disable bump mapping
extern	cvar_t	sh_playershadow;//PENTA: the player casts a shadow (the one YOU are playing with, others always cast shadows)
extern	cvar_t	sh_nocache;
extern	cvar_t	sh_glares;
extern	cvar_t	sh_noefrags;
extern  cvar_t  sh_showtangent;
extern  cvar_t	sh_noshadowpopping;
extern	cvar_t	fog_waterfog;
extern	cvar_t	gl_caustics;
extern	cvar_t	gl_truform;
extern	cvar_t	gl_truform_tesselation;
extern	cvar_t	gl_compress_textures;
extern	cvar_t	gl_mesherror;
extern  cvar_t	scr_fov;	// 10 - 170
extern	cvar_t	mir_detail; //PENTA: mirror detail level
							//0: no mirrors
							//1: World only
							//2: World & player
							//3: Full
extern	cvar_t	mir_frameskip; //PENTA: mirror is updated every i'th frame
extern	cvar_t	mir_forcewater; //Forces all quake's water to be reflecting.
extern	cvar_t	mir_distance; //maximum drawing distance
extern  cvar_t	gl_wireframe;
extern  cvar_t	fog_r;
extern  cvar_t	fog_g;
extern  cvar_t	fog_b;
extern  cvar_t	fog_start;
extern  cvar_t	fog_end;
extern  cvar_t	gl_fog;
extern	float	fog_color[4];
extern	cvar_t	r_tangentscale; //scale tangent/binormal by this
extern  cvar_t  sh_delux;
extern  cvar_t  sh_rtlights;
extern	cvar_t	gl_clipboth;
extern	cvar_t  gl_displacement;

extern	int			mirrortexturenum;	// quake texturenum, not gltexturenum
extern	qboolean	mirror;
extern	qboolean	glare;
extern	mplane_t	*mirror_plane;
extern  mplane_t	mirror_far_plane;
extern	int			mirror_clipside;
extern  float vid_gamma;

extern	float	r_world_matrix[16];
extern	double	r_Dproject_matrix[16];			//PENTA	<AWE> added "extern".
extern	double	r_Dworld_matrix[16];			//PENTA	<AWE> added "extern".
extern  int 	r_Iviewport[4];				//PENTA

extern	float color_black[4];

#define NUMVERTEXNORMALS	162

extern float	r_avertexnormals[NUMVERTEXNORMALS][3];


extern	const char *gl_vendor;
extern	const char *gl_renderer;
extern	const char *gl_version;
extern	const char *gl_extensions;

void GL_Bind (int texnum);

#ifndef _WIN32
#ifndef APIENTRY
# define APIENTRY /* */
#endif
#endif

#if !defined (__APPLE__) && !defined (MACOSX)


// Multitexture
//#define    TEXTURE0_SGIS				0x835E
//#define    TEXTURE1_SGIS				0x835F

/* Arb Imaging stuff
not an extension: see http://www.opengl.org/developers/documentation/OpenGL12.html#imaging
*/

typedef void (APIENTRY *PFNBLENDCOLORPROC)(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);

#define GL_CONSTANT_COLOR_EXT						0x8001
#define GL_ONE_MINUS_CONSTANT_COLOR_EXT				0x8002
#define GL_CONSTANT_ALPHA_EXT						0x8003
#define GL_ONE_MINUS_CONSTANT_ALPHA_EXT				0x8004
extern PFNBLENDCOLORPROC qglBlendColor;

#define GL_COLOR_MATRIX				0x80B1
#define GL_COLOR_MATRIX_STACK_DEPTH		0x80B2
#define GL_MAX_COLOR_MATRIX_STACK_DEPTH		0x80B3

#define GL_POST_COLOR_MATRIX_RED_SCALE		0x80B4
#define GL_POST_COLOR_MATRIX_GREEN_SCALE		0x80B5
#define GL_POST_COLOR_MATRIX_BLUE_SCALE		0x80B6
#define GL_POST_COLOR_MATRIX_ALPHA_SCALE		0x80B7
#define GL_POST_COLOR_MATRIX_RED_BIAS		0x80B8
#define GL_POST_COLOR_MATRIX_GREEN_BIAS		0x80B9
#define GL_POST_COLOR_MATRIX_BLUE_BIAS		0x80BA
#define GL_POST_COLOR_MATRIX_ALPHA_BIAS		0x80BB



// ARB_texture_compression defines
#define GL_COMPRESSED_RGB_ARB                 0x84ED
#define GL_COMPRESSED_RGBA_ARB                0x84EE

//HP_occlusion_test defines
#define GL_OCCLUSION_TEST_HP              0x8165
#define GL_OCCLUSION_TEST_RESULT_HP       0x8166
extern qboolean gl_occlusiontest;
extern int occlusion_cut_meshes;
extern int occlusion_cut_entities;
extern int occlusion_cut_lights;

#define GL_STENCIL_BACK_FUNC_ATI                    0x8800
#define GL_STENCIL_BACK_FAIL_ATI                    0x8801
#define GL_STENCIL_BACK_PASS_DEPTH_FAIL_ATI         0x8802
#define GL_STENCIL_BACK_PASS_DEPTH_PASS_ATI         0x8803

typedef void (APIENTRY *PFNGLSTENCILOPSEPARATEATIPROC)(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (APIENTRY *PFNGLSTENCILFUNCSEPARATEATIPROC)(GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);

extern PFNGLSTENCILOPSEPARATEATIPROC qglStencilOpSeparateATI;
extern PFNGLSTENCILFUNCSEPARATEATIPROC qglStencilFuncSeparateATI;

#endif /* !__APPLE__ && !MACOSX */

// <AWE> : MacOS X 10.2: defined in <OpenGL/glext.h>
#if !defined (__APPLE__) && !defined (MACOSX) 

#define GL_COMBINE_ARB                    0x8570
#define GL_COMBINE_RGB_ARB                0x8571
#define GL_COMBINE_ALPHA_ARB              0x8572
#define GL_RGB_SCALE_ARB                  0x8573
#define GL_ADD_SIGNED_ARB                 0x8574
#define GL_INTERPOLATE_ARB                0x8575
#define GL_SUBTRACT_ARB                   0x84E7
#define GL_CONSTANT_ARB                   0x8576
#define GL_PRIMARY_COLOR_ARB              0x8577
#define GL_PREVIOUS_ARB                   0x8578
#define GL_SOURCE0_RGB_ARB                0x8580
#define GL_SOURCE1_RGB_ARB                0x8581
#define GL_SOURCE2_RGB_ARB                0x8582
#define GL_SOURCE3_RGB_ARB                0x8583
#define GL_SOURCE4_RGB_ARB                0x8584
#define GL_SOURCE5_RGB_ARB                0x8585
#define GL_SOURCE6_RGB_ARB                0x8586
#define GL_SOURCE7_RGB_ARB                0x8587
#define GL_SOURCE0_ALPHA_ARB              0x8588
#define GL_SOURCE1_ALPHA_ARB              0x8589
#define GL_SOURCE2_ALPHA_ARB              0x858A
#define GL_SOURCE3_ALPHA_ARB              0x858B
#define GL_SOURCE4_ALPHA_ARB              0x858C
#define GL_SOURCE5_ALPHA_ARB              0x858D
#define GL_SOURCE6_ALPHA_ARB              0x858E
#define GL_SOURCE7_ALPHA_ARB              0x858F
#define GL_OPERAND0_RGB_ARB               0x8590
#define GL_OPERAND1_RGB_ARB               0x8591
#define GL_OPERAND2_RGB_ARB               0x8592
#define GL_OPERAND3_RGB_ARB               0x8593
#define GL_OPERAND4_RGB_ARB               0x8594
#define GL_OPERAND5_RGB_ARB               0x8595
#define GL_OPERAND6_RGB_ARB               0x8596
#define GL_OPERAND7_RGB_ARB               0x8597
#define GL_OPERAND0_ALPHA_ARB             0x8598
#define GL_OPERAND1_ALPHA_ARB             0x8599
#define GL_OPERAND2_ALPHA_ARB             0x859A
#define GL_OPERAND3_ALPHA_ARB             0x859B
#define GL_OPERAND4_ALPHA_ARB             0x859C
#define GL_OPERAND5_ALPHA_ARB             0x859D
#define GL_OPERAND6_ALPHA_ARB             0x859E
#define GL_OPERAND7_ALPHA_ARB             0x859F

/*
#define	GL_DOT3_RGB_EXT					  0x8740
#define	GL_DOT3_RGBA_EXT				  0x8741
*/
#define GL_DOT3_RGB_ARB					0x86AE
#define GL_DOT3_RGBA_ARB				0x86AF


//PENTA: Cube mapping
#define GL_NORMAL_MAP_ARB                 0x8511
#define GL_REFLECTION_MAP_ARB             0x8512
#define GL_TEXTURE_CUBE_MAP_ARB           0x8513
#define GL_TEXTURE_BINDING_CUBE_MAP_ARB   0x8514
#define GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB 0x8515
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB 0x8516
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB 0x8517
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB 0x8518
#define GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB 0x8519
#define GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB 0x851A
#define GL_PROXY_TEXTURE_CUBE_MAP_ARB     0x851B
#define GL_MAX_CUBE_MAP_TEXTURE_SIZE_ARB  0x851C

#define GL_TEXTURE_MAX_ANISOTROPY_EXT		0x84FE
#define GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT	0x84FF


#endif /* !__APPLE__ && !MACOSX */


#include "glNV.h"

// <AWE> : MacOS X 10.2: defined in <OpenGL/glext.h>
#if !defined (__APPLE__) && !defined (MACOSX) && !defined(SDL) && !defined (__glx__)

//PENTA: texture3d
#define GL_PACK_SKIP_IMAGES               0x806B
#define GL_PACK_SKIP_IMAGES_EXT           0x806B
#define GL_PACK_IMAGE_HEIGHT              0x806C
#define GL_PACK_IMAGE_HEIGHT_EXT          0x806C
#define GL_UNPACK_SKIP_IMAGES             0x806D
#define GL_UNPACK_SKIP_IMAGES_EXT         0x806D
#define GL_UNPACK_IMAGE_HEIGHT            0x806E
#define GL_UNPACK_IMAGE_HEIGHT_EXT        0x806E
#define GL_TEXTURE_3D                     0x806F
#define GL_TEXTURE_3D_EXT                 0x806F
#define GL_PROXY_TEXTURE_3D               0x8070
#define GL_PROXY_TEXTURE_3D_EXT           0x8070
#define GL_TEXTURE_DEPTH                  0x8071
#define GL_TEXTURE_DEPTH_EXT              0x8071
#define GL_TEXTURE_WRAP_R                 0x8072
#define GL_TEXTURE_WRAP_R_EXT             0x8072
#define GL_MAX_3D_TEXTURE_SIZE            0x8073
#define GL_MAX_3D_TEXTURE_SIZE_EXT        0x8073

#endif /* !__APPLE__ && !MACOSX && !SDL && !__glx__ */

typedef void (APIENTRY * PFNGLTEXIMAGE3DEXT)(GLenum target, GLint level, GLenum internalformat,
											 GLsizei width, GLsizei height, GLsizei depth,
											 GLint border, GLenum format, GLenum type,
											 const GLvoid* pixels);
extern PFNGLTEXIMAGE3DEXT qglTexImage3DEXT;

// <AWE> : NV_vertex_program will never be supported under any other OS than Windows, because it got
//	   replaced by the official ARB spec "ARB_vertex_program".
//
//	   Todo: - Add hybrid support for NV & ARB vertex_programs.
//		 - Port the current vertex program from NV to ARB.

/* ARB_vertex_program */
/*
#define GL_VERTEX_PROGRAM_ARB                            0x8620
#define GL_VERTEX_PROGRAM_POINT_SIZE_ARB                 0x8642
#define GL_VERTEX_PROGRAM_TWO_SIDE_ARB                   0x8643
#define GL_PROGRAM_FORMAT_ASCII_ARB                      0x8875
#define GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB               0x8622
#define GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB                  0x8623
#define GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB                0x8624
#define GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB                  0x8625
#define GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB            0x886A
#define GL_CURRENT_VERTEX_ATTRIB_ARB                     0x8626
#define GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB               0x8645
#define GL_PROGRAM_LENGTH_ARB                            0x8627
#define GL_PROGRAM_FORMAT_ARB                            0x8876
#define GL_PROGRAM_NAME_ARB                              0x8677
#define GL_PROGRAM_INSTRUCTIONS_ARB                      0x88A0
#define GL_MAX_PROGRAM_INSTRUCTIONS_ARB                  0x88A1
#define GL_PROGRAM_NATIVE_INSTRUCTIONS_ARB               0x88A2
#define GL_MAX_PROGRAM_NATIVE_INSTRUCTIONS_ARB           0x88A3
#define GL_PROGRAM_TEMPORARIES_ARB                       0x88A4
#define GL_MAX_PROGRAM_TEMPORARIES_ARB                   0x88A5
#define GL_PROGRAM_NATIVE_TEMPORARIES_ARB                0x88A6
#define GL_MAX_PROGRAM_NATIVE_TEMPORARIES_ARB            0x88A7
#define GL_PROGRAM_PARAMETERS_ARB                        0x88A8
#define GL_MAX_PROGRAM_PARAMETERS_ARB                    0x88A9
#define GL_PROGRAM_NATIVE_PARAMETERS_ARB                 0x88AA
#define GL_MAX_PROGRAM_NATIVE_PARAMETERS_ARB             0x88AB
#define GL_PROGRAM_ATTRIBS_ARB                           0x88AC
#define GL_MAX_PROGRAM_ATTRIBS_ARB                       0x88AD
#define GL_PROGRAM_NATIVE_ATTRIBS_ARB                    0x88AE
#define GL_MAX_PROGRAM_NATIVE_ATTRIBS_ARB                0x88AF
#define GL_PROGRAM_ADDRESS_REGISTERS_ARB                 0x88B0
#define GL_MAX_PROGRAM_ADDRESS_REGISTERS_ARB             0x88B1
#define GL_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB          0x88B2
#define GL_MAX_PROGRAM_NATIVE_ADDRESS_REGISTERS_ARB      0x88B3
#define GL_MAX_PROGRAM_LOCAL_PARAMETERS_ARB              0x88B4
#define GL_MAX_PROGRAM_ENV_PARAMETERS_ARB                0x88B5
#define GL_PROGRAM_UNDER_NATIVE_LIMITS_ARB               0x88B6
#define GL_PROGRAM_STRING_ARB                            0x8628
#define GL_PROGRAM_ERROR_POSITION_ARB                    0x864B
#define GL_CURRENT_MATRIX_ARB                            0x8641
#define GL_TRANSPOSE_CURRENT_MATRIX_ARB                  0x88B7
#define GL_CURRENT_MATRIX_STACK_DEPTH_ARB                0x8640
#define GL_MAX_VERTEX_ATTRIBS_ARB                        0x8869
#define GL_MAX_PROGRAM_MATRICES_ARB                      0x862F
#define GL_MAX_PROGRAM_MATRIX_STACK_DEPTH_ARB            0x862E
#define GL_PROGRAM_ERROR_STRING_ARB                      0x8874

#define GL_MATRIX0_ARB                                   0x88C0
#define GL_MATRIX1_ARB                                   0x88C1
#define GL_MATRIX2_ARB                                   0x88C2
#define GL_MATRIX3_ARB                                   0x88C3
#define GL_MATRIX4_ARB                                   0x88C4
#define GL_MATRIX5_ARB                                   0x88C5
#define GL_MATRIX6_ARB                                   0x88C6
#define GL_MATRIX7_ARB                                   0x88C7
#define GL_MATRIX8_ARB                                   0x88C8
#define GL_MATRIX9_ARB                                   0x88C9
#define GL_MATRIX10_ARB                                  0x88CA
#define GL_MATRIX11_ARB                                  0x88CB
#define GL_MATRIX12_ARB                                  0x88CC
#define GL_MATRIX13_ARB                                  0x88CD
#define GL_MATRIX14_ARB                                  0x88CE
#define GL_MATRIX15_ARB                                  0x88CF
#define GL_MATRIX16_ARB                                  0x88D0
#define GL_MATRIX17_ARB                                  0x88D1
#define GL_MATRIX18_ARB                                  0x88D2
#define GL_MATRIX19_ARB                                  0x88D3
#define GL_MATRIX20_ARB                                  0x88D4
#define GL_MATRIX21_ARB                                  0x88D5
#define GL_MATRIX22_ARB                                  0x88D6
#define GL_MATRIX23_ARB                                  0x88D7
#define GL_MATRIX24_ARB                                  0x88D8
#define GL_MATRIX25_ARB                                  0x88D9
#define GL_MATRIX26_ARB                                  0x88DA
#define GL_MATRIX27_ARB                                  0x88DB
#define GL_MATRIX28_ARB                                  0x88DC
#define GL_MATRIX29_ARB                                  0x88DD
#define GL_MATRIX30_ARB                                  0x88DE
#define GL_MATRIX31_ARB                                  0x88DF

typedef void (APIENTRY * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint id);
typedef void (APIENTRY * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint *programs);
typedef void (APIENTRY * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint *programs);
typedef void (APIENTRY * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, GLvoid *string);
typedef void (APIENTRY * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void (APIENTRY * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void (APIENTRY * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid **pointer);
typedef GLboolean (APIENTRY * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void (APIENTRY * PFNGPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const GLvoid *string);
typedef void (APIENTRY * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte *v);

extern PFNGLBINDPROGRAMARBPROC 			qglBindProgramARB;
extern PFNGLDELETEPROGRAMSARBPROC 		qglDeleteProgramsARB;
extern PFNGLGENPROGRAMSARBPROC 			qglGenProgramsARB;
extern PFNGLGETPROGRAMIVARBPROC 		qglGetProgramivARB;
extern PFNGLGETPROGRAMSTRINGARBPROC 		qglGetProgramStringARB;
extern PFNGLGETVERTEXATTRIBDVARBPROC 		qglGetVertexAttribdvARB;
extern PFNGLGETVERTEXATTRIBFVARBPROC 		qglGetVertexAttribfvARB;
extern PFNGLGETVERTEXATTRIBIVARBPROC 		qglGetVertexAttribivARB;
extern PFNGLGETVERTEXATTRIBPOINTERVARBPROC	qglGetVertexAttribPointervARB;
extern PFNGLISPROGRAMARBPROC 			qglIsProgramARB;
extern PFNGPROGRAMSTRINGARBPROC 		qglProgramStringARB;
extern PFNGLVERTEXATTRIB1DARBPROC		qglVertexAttrib1dARB;
extern PFNGLVERTEXATTRIB1DVARBPROC 		qglVertexAttrib1dvARB;
extern PFNGLVERTEXATTRIB1FARBPROC		qglVertexAttrib1fARB;
extern PFNGLVERTEXATTRIB1FVARBPROC		qglVertexAttrib1fvARB;
extern PFNGLVERTEXATTRIB1SARBPROC		qglVertexAttrib1sARB;
extern PFNGLVERTEXATTRIB1SVARBPROC		qglVertexAttrib1svARB;
extern PFNGLVERTEXATTRIB2DARBPROC		qglVertexAttrib2dARB;
extern PFNGLVERTEXATTRIB2DVARBPROC		qglVertexAttrib2dvARB;
extern PFNGLVERTEXATTRIB2FARBPROC		qglVertexAttrib2fARB;
extern PFNGLVERTEXATTRIB2FVARBPROC		qglVertexAttrib2fvARB;
extern PFNGLVERTEXATTRIB2SARBPROC		qglVertexAttrib2sARB;
extern PFNGLVERTEXATTRIB2SVARBPROC		qglVertexAttrib2svARB;
extern PFNGLVERTEXATTRIB3DARBPROC		qglVertexAttrib3dARB;
extern PFNGLVERTEXATTRIB3DVARBPROC		qglVertexAttrib3dvARB;
extern PFNGLVERTEXATTRIB3FARBPROC		qglVertexAttrib3fARB;
extern PFNGLVERTEXATTRIB3FVARBPROC		qglVertexAttrib3fvARB;
extern PFNGLVERTEXATTRIB3SARBPROC		qglVertexAttrib3sARB;
extern PFNGLVERTEXATTRIB3SVARBPROC		qglVertexAttrib3svARB;
extern PFNGLVERTEXATTRIB4DARBPROC		qglVertexAttrib4dARB;
extern PFNGLVERTEXATTRIB4DVARBPROC		qglVertexAttrib4dvARB;
extern PFNGLVERTEXATTRIB4FARBPROC		qglVertexAttrib4fARB;
extern PFNGLVERTEXATTRIB4FVARBPROC		qglVertexAttrib4fvARB;
extern PFNGLVERTEXATTRIB4SARBPROC		qglVertexAttrib4sARB;
extern PFNGLVERTEXATTRIB4SVARBPROC		qglVertexAttrib4svARB;
extern PFNGLVERTEXATTRIB4UBVARBPROC		qglVertexAttrib4ubvARB;
*/

//PENTA: VERTEX_PROGRAM

#ifndef GL_NV_vertex_program
/* NV_vertex_program */
#define GL_VERTEX_PROGRAM_NV              0x8620
#define GL_VERTEX_STATE_PROGRAM_NV        0x8621
#define GL_ATTRIB_ARRAY_SIZE_NV           0x8623
#define GL_ATTRIB_ARRAY_STRIDE_NV         0x8624
#define GL_ATTRIB_ARRAY_TYPE_NV           0x8625
#define GL_CURRENT_ATTRIB_NV              0x8626
#define GL_PROGRAM_LENGTH_NV              0x8627
#define GL_PROGRAM_STRING_NV              0x8628
#define GL_MODELVIEW_PROJECTION_NV        0x8629
#define GL_IDENTITY_NV                    0x862A
#define GL_INVERSE_NV                     0x862B
#define GL_TRANSPOSE_NV                   0x862C
#define GL_INVERSE_TRANSPOSE_NV           0x862D
#define GL_MAX_TRACK_MATRIX_STACK_DEPTH_NV 0x862E
#define GL_MAX_TRACK_MATRICES_NV          0x862F
#define GL_MATRIX0_NV                     0x8630
#define GL_MATRIX1_NV                     0x8631
#define GL_MATRIX2_NV                     0x8632
#define GL_MATRIX3_NV                     0x8633
#define GL_MATRIX4_NV                     0x8634
#define GL_MATRIX5_NV                     0x8635
#define GL_MATRIX6_NV                     0x8636
#define GL_MATRIX7_NV                     0x8637
#define GL_CURRENT_MATRIX_STACK_DEPTH_NV  0x8640
#define GL_CURRENT_MATRIX_NV              0x8641
#define GL_VERTEX_PROGRAM_POINT_SIZE_NV   0x8642
#define GL_VERTEX_PROGRAM_TWO_SIDE_NV     0x8643
#define GL_PROGRAM_PARAMETER_NV           0x8644
#define GL_ATTRIB_ARRAY_POINTER_NV        0x8645
#define GL_PROGRAM_TARGET_NV              0x8646
#define GL_PROGRAM_RESIDENT_NV            0x8647
#define GL_TRACK_MATRIX_NV                0x8648
#define GL_TRACK_MATRIX_TRANSFORM_NV      0x8649
#define GL_VERTEX_PROGRAM_BINDING_NV      0x864A
#define GL_PROGRAM_ERROR_POSITION_NV      0x864B
#define GL_VERTEX_ATTRIB_ARRAY0_NV        0x8650
#define GL_VERTEX_ATTRIB_ARRAY1_NV        0x8651
#define GL_VERTEX_ATTRIB_ARRAY2_NV        0x8652
#define GL_VERTEX_ATTRIB_ARRAY3_NV        0x8653
#define GL_VERTEX_ATTRIB_ARRAY4_NV        0x8654
#define GL_VERTEX_ATTRIB_ARRAY5_NV        0x8655
#define GL_VERTEX_ATTRIB_ARRAY6_NV        0x8656
#define GL_VERTEX_ATTRIB_ARRAY7_NV        0x8657
#define GL_VERTEX_ATTRIB_ARRAY8_NV        0x8658
#define GL_VERTEX_ATTRIB_ARRAY9_NV        0x8659
#define GL_VERTEX_ATTRIB_ARRAY10_NV       0x865A
#define GL_VERTEX_ATTRIB_ARRAY11_NV       0x865B
#define GL_VERTEX_ATTRIB_ARRAY12_NV       0x865C
#define GL_VERTEX_ATTRIB_ARRAY13_NV       0x865D
#define GL_VERTEX_ATTRIB_ARRAY14_NV       0x865E
#define GL_VERTEX_ATTRIB_ARRAY15_NV       0x865F
#define GL_MAP1_VERTEX_ATTRIB0_4_NV       0x8660
#define GL_MAP1_VERTEX_ATTRIB1_4_NV       0x8661
#define GL_MAP1_VERTEX_ATTRIB2_4_NV       0x8662
#define GL_MAP1_VERTEX_ATTRIB3_4_NV       0x8663
#define GL_MAP1_VERTEX_ATTRIB4_4_NV       0x8664
#define GL_MAP1_VERTEX_ATTRIB5_4_NV       0x8665
#define GL_MAP1_VERTEX_ATTRIB6_4_NV       0x8666
#define GL_MAP1_VERTEX_ATTRIB7_4_NV       0x8667
#define GL_MAP1_VERTEX_ATTRIB8_4_NV       0x8668
#define GL_MAP1_VERTEX_ATTRIB9_4_NV       0x8669
#define GL_MAP1_VERTEX_ATTRIB10_4_NV      0x866A
#define GL_MAP1_VERTEX_ATTRIB11_4_NV      0x866B
#define GL_MAP1_VERTEX_ATTRIB12_4_NV      0x866C
#define GL_MAP1_VERTEX_ATTRIB13_4_NV      0x866D
#define GL_MAP1_VERTEX_ATTRIB14_4_NV      0x866E
#define GL_MAP1_VERTEX_ATTRIB15_4_NV      0x866F
#define GL_MAP2_VERTEX_ATTRIB0_4_NV       0x8670
#define GL_MAP2_VERTEX_ATTRIB1_4_NV       0x8671
#define GL_MAP2_VERTEX_ATTRIB2_4_NV       0x8672
#define GL_MAP2_VERTEX_ATTRIB3_4_NV       0x8673
#define GL_MAP2_VERTEX_ATTRIB4_4_NV       0x8674
#define GL_MAP2_VERTEX_ATTRIB5_4_NV       0x8675
#define GL_MAP2_VERTEX_ATTRIB6_4_NV       0x8676
#define GL_MAP2_VERTEX_ATTRIB7_4_NV       0x8677
#define GL_MAP2_VERTEX_ATTRIB8_4_NV       0x8678
#define GL_MAP2_VERTEX_ATTRIB9_4_NV       0x8679
#define GL_MAP2_VERTEX_ATTRIB10_4_NV      0x867A
#define GL_MAP2_VERTEX_ATTRIB11_4_NV      0x867B
#define GL_MAP2_VERTEX_ATTRIB12_4_NV      0x867C
#define GL_MAP2_VERTEX_ATTRIB13_4_NV      0x867D
#define GL_MAP2_VERTEX_ATTRIB14_4_NV      0x867E
#define GL_MAP2_VERTEX_ATTRIB15_4_NV      0x867F

/* NV_vertex_program */
typedef GLboolean (APIENTRY * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint *programs, GLboolean *residences);
typedef void (APIENTRY * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void (APIENTRY * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
typedef void (APIENTRY * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat *params);
typedef void (APIENTRY * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint *programs);
typedef void (APIENTRY * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble *params);
typedef void (APIENTRY * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat *params);
typedef void (APIENTRY * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte *program);
typedef void (APIENTRY * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble *params);
typedef void (APIENTRY * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat *params);
typedef void (APIENTRY * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, GLvoid* *pointer);
typedef GLboolean (APIENTRY * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void (APIENTRY * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte *program);
typedef void (APIENTRY * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (APIENTRY * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble *v);
typedef void (APIENTRY * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (APIENTRY * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat *v);
typedef void (APIENTRY * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLdouble *v);
typedef void (APIENTRY * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat *v);
typedef void (APIENTRY * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, const GLuint *programs);
typedef void (APIENTRY * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void (APIENTRY * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint fsize, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void (APIENTRY * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void (APIENTRY * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (APIENTRY * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei count, const GLdouble *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei count, const GLfloat *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei count, const GLshort *v);
typedef void (APIENTRY * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei count, const GLubyte *v);
#endif

extern PFNGLAREPROGRAMSRESIDENTNVPROC qglAreProgramsResidentNV ;
extern PFNGLBINDPROGRAMNVPROC qglBindProgramNV ;
extern PFNGLDELETEPROGRAMSNVPROC qglDeleteProgramsNV ;
extern PFNGLEXECUTEPROGRAMNVPROC qglExecuteProgramNV ;
extern PFNGLGENPROGRAMSNVPROC qglGenProgramsNV ;
extern PFNGLGETPROGRAMPARAMETERDVNVPROC qglGetProgramParameterdvNV ;
extern PFNGLGETPROGRAMPARAMETERFVNVPROC qglGetProgramParameterfvNV ;
extern PFNGLGETPROGRAMIVNVPROC qglGetProgramivNV ;
extern PFNGLGETPROGRAMSTRINGNVPROC qglGetProgramStringNV ;
extern PFNGLGETTRACKMATRIXIVNVPROC qglGetTrackMatrixivNV ;
extern PFNGLGETVERTEXATTRIBDVNVPROC qglGetVertexAttribdvNV ;
extern PFNGLGETVERTEXATTRIBFVNVPROC qglGetVertexAttribfvNV ;
extern PFNGLGETVERTEXATTRIBIVNVPROC qglGetVertexAttribivNV ;
extern PFNGLGETVERTEXATTRIBPOINTERVNVPROC qglGetVertexAttribPointervNV ;
extern PFNGLISPROGRAMNVPROC qglIsProgramNV ;
extern PFNGLLOADPROGRAMNVPROC qglLoadProgramNV ;
extern PFNGLPROGRAMPARAMETER4DNVPROC qglProgramParameter4dNV ;
extern PFNGLPROGRAMPARAMETER4DVNVPROC qglProgramParameter4dvNV ;
extern PFNGLPROGRAMPARAMETER4FNVPROC qglProgramParameter4fNV ;
extern PFNGLPROGRAMPARAMETER4FVNVPROC qglProgramParameter4fvNV ;
extern PFNGLPROGRAMPARAMETERS4DVNVPROC qglProgramParameters4dvNV ;
extern PFNGLPROGRAMPARAMETERS4FVNVPROC qglProgramParameters4fvNV ;
extern PFNGLREQUESTRESIDENTPROGRAMSNVPROC qglRequestResidentProgramsNV ;
extern PFNGLTRACKMATRIXNVPROC qglTrackMatrixNV ;
extern PFNGLVERTEXATTRIBPOINTERNVPROC qglVertexAttribPointerNV ;
extern PFNGLVERTEXATTRIB1DNVPROC qglVertexAttrib1dNV ;
extern PFNGLVERTEXATTRIB1DVNVPROC qglVertexAttrib1dvNV ;
extern PFNGLVERTEXATTRIB1FNVPROC qglVertexAttrib1fNV ;
extern PFNGLVERTEXATTRIB1FVNVPROC qglVertexAttrib1fvNV ;
extern PFNGLVERTEXATTRIB1SNVPROC qglVertexAttrib1sNV ;
extern PFNGLVERTEXATTRIB1SVNVPROC qglVertexAttrib1svNV ;
extern PFNGLVERTEXATTRIB2DNVPROC qglVertexAttrib2dNV ;
extern PFNGLVERTEXATTRIB2DVNVPROC qglVertexAttrib2dvNV ;
extern PFNGLVERTEXATTRIB2FNVPROC qglVertexAttrib2fNV ;
extern PFNGLVERTEXATTRIB2FVNVPROC qglVertexAttrib2fvNV ;
extern PFNGLVERTEXATTRIB2SNVPROC qglVertexAttrib2sNV ;
extern PFNGLVERTEXATTRIB2SVNVPROC qglVertexAttrib2svNV ;
extern PFNGLVERTEXATTRIB3DNVPROC qglVertexAttrib3dNV ;
extern PFNGLVERTEXATTRIB3DVNVPROC qglVertexAttrib3dvNV ;
extern PFNGLVERTEXATTRIB3FNVPROC qglVertexAttrib3fNV ;
extern PFNGLVERTEXATTRIB3FVNVPROC qglVertexAttrib3fvNV ;
extern PFNGLVERTEXATTRIB3SNVPROC qglVertexAttrib3sNV ;
extern PFNGLVERTEXATTRIB3SVNVPROC qglVertexAttrib3svNV ;
extern PFNGLVERTEXATTRIB4DNVPROC qglVertexAttrib4dNV ;
extern PFNGLVERTEXATTRIB4DVNVPROC qglVertexAttrib4dvNV ;
extern PFNGLVERTEXATTRIB4FNVPROC qglVertexAttrib4fNV ;
extern PFNGLVERTEXATTRIB4FVNVPROC qglVertexAttrib4fvNV ;
extern PFNGLVERTEXATTRIB4SNVPROC qglVertexAttrib4sNV ;
extern PFNGLVERTEXATTRIB4SVNVPROC qglVertexAttrib4svNV ;
extern PFNGLVERTEXATTRIB4UBVNVPROC qglVertexAttrib4ubvNV ;
extern PFNGLVERTEXATTRIBS1DVNVPROC qglVertexAttribs1dvNV ;
extern PFNGLVERTEXATTRIBS1FVNVPROC qglVertexAttribs1fvNV ;
extern PFNGLVERTEXATTRIBS1SVNVPROC qglVertexAttribs1svNV ;
extern PFNGLVERTEXATTRIBS2DVNVPROC qglVertexAttribs2dvNV ;
extern PFNGLVERTEXATTRIBS2FVNVPROC qglVertexAttribs2fvNV ;
extern PFNGLVERTEXATTRIBS2SVNVPROC qglVertexAttribs2svNV ;
extern PFNGLVERTEXATTRIBS3DVNVPROC qglVertexAttribs3dvNV ;
extern PFNGLVERTEXATTRIBS3FVNVPROC qglVertexAttribs3fvNV ;
extern PFNGLVERTEXATTRIBS3SVNVPROC qglVertexAttribs3svNV ;
extern PFNGLVERTEXATTRIBS4DVNVPROC qglVertexAttribs4dvNV ;
extern PFNGLVERTEXATTRIBS4FVNVPROC qglVertexAttribs4fvNV ;
extern PFNGLVERTEXATTRIBS4SVNVPROC qglVertexAttribs4svNV ;
extern PFNGLVERTEXATTRIBS4UBVNVPROC qglVertexAttribs4ubvNV ;

/* GL_ARB_vertex_buffer_object */

#define GL_BUFFER_SIZE_ARB                0x8764
#define GL_BUFFER_USAGE_ARB               0x8765
#define GL_ARRAY_BUFFER_ARB               0x8892
#define GL_ELEMENT_ARRAY_BUFFER_ARB       0x8893
#define GL_ARRAY_BUFFER_BINDING_ARB       0x8894
#define GL_ELEMENT_ARRAY_BUFFER_BINDING_ARB 0x8895
#define GL_VERTEX_ARRAY_BUFFER_BINDING_ARB 0x8896
#define GL_NORMAL_ARRAY_BUFFER_BINDING_ARB 0x8897
#define GL_COLOR_ARRAY_BUFFER_BINDING_ARB 0x8898
#define GL_INDEX_ARRAY_BUFFER_BINDING_ARB 0x8899
#define GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB 0x889A
#define GL_EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB 0x889B
#define GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB 0x889C
#define GL_FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB 0x889D
#define GL_WEIGHT_ARRAY_BUFFER_BINDING_ARB 0x889E
#define GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB 0x889F
#define GL_READ_ONLY_ARB                  0x88B8
#define GL_WRITE_ONLY_ARB                 0x88B9
#define GL_READ_WRITE_ARB                 0x88BA
#define GL_BUFFER_ACCESS_ARB              0x88BB
#define GL_BUFFER_MAPPED_ARB              0x88BC
#define GL_BUFFER_MAP_POINTER_ARB         0x88BD
#define GL_STREAM_DRAW_ARB                0x88E0
#define GL_STREAM_READ_ARB                0x88E1
#define GL_STREAM_COPY_ARB                0x88E2
#define GL_STATIC_DRAW_ARB                0x88E4
#define GL_STATIC_READ_ARB                0x88E5
#define GL_STATIC_COPY_ARB                0x88E6
#define GL_DYNAMIC_DRAW_ARB               0x88E8
#define GL_DYNAMIC_READ_ARB               0x88E9
#define GL_DYNAMIC_COPY_ARB               0x88EA

typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void (APIENTRY * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void (APIENTRY * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint *buffers);
typedef void (APIENTRY * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint *buffers);
typedef GLboolean (APIENTRY * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void (APIENTRY * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const GLvoid *data, GLenum usage);
typedef void (APIENTRY * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid *data);
typedef void (APIENTRY * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid *data);
typedef GLvoid* (APIENTRY * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean (APIENTRY * PFNGLUNMAPBUFFERARBPROC) (GLenum target);
typedef void (APIENTRY * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (APIENTRY * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, GLvoid* *params);

extern PFNGLBINDBUFFERARBPROC qglBindBufferARB;
extern PFNGLDELETEBUFFERSARBPROC qglDeleteBuffersARB;
extern PFNGLGENBUFFERSARBPROC qglGenBuffersARB;
extern PFNGLISBUFFERARBPROC qglIsBufferARB;
extern PFNGLBUFFERDATAARBPROC qglBufferDataARB;
extern PFNGLBUFFERSUBDATAARBPROC qglBufferSubDataARB;
extern PFNGLGETBUFFERSUBDATAARBPROC qglGetBufferSubDataARB;
extern PFNGLMAPBUFFERARBPROC qglMapBufferARB;
extern PFNGLUNMAPBUFFERARBPROC qglUnmapBufferARB;
extern PFNGLGETBUFFERPARAMETERIVARBPROC qglGetBufferParameterivARB;
extern PFNGLGETBUFFERPOINTERVARBPROC qglGetBufferPointervARB;

/* clamp_to_edge */
#define GL_CLAMP_TO_EDGE                	0x812F

/* ATI_texture_mirror_once */
#define GL_MIRROR_CLAMP_ATI                     0x8742
#define GL_MIRROR_CLAMP_TO_EDGE_ATI             0x8743


extern qboolean gl_mtexable;
extern qboolean gl_texturefilteranisotropic; // <AWE> true if anisotropic texture filtering available.

typedef enum
{
	GENERIC = 0,
	GEFORCE,
	GEFORCE3,
	RADEON,
	PARHELIA,
	ARB,
        NV3x,
        GL2
} qcardtype;
extern qcardtype gl_cardtype;

//extern qboolean gl_nvcombiner; //PENTA: true if nvdida texture shaders are present
//extern qboolean gl_geforce3;
//extern qboolean gl_radeon;//PA:
extern qboolean gl_vbo;
extern qboolean gl_texcomp;

extern GLfloat	gl_textureanisotropylevel; // <AWE> required for anisotropic textures.

void GL_DisableMultitexture(void);
void GL_EnableMultitexture(void);

//PENTA: Stencil shadows

typedef struct screenrect_s {
	int coords [4];
	struct screenrect_s *next;
} screenrect_t;


typedef union lightcmd_u {
  int asInt;
  float asFloat;
  vec_t asVec;
  void *asVoid;
} lightcmd_t;

typedef struct {
	vec3_t mins, maxs;
} aabox_t;

typedef struct shadowlight_s {
	vec3_t	origin;		//position of light source
	vec3_t	baseColor, color;		//light color, animated color
	float	radius;		//radius of light source (doesn't light anyting out of that circle)
						//so we can "clip" our shadowvolumes against that circle
	vec3_t	radiusv;		//the 3 radiusses of the elipse around the light
	aabox_t box;		//bounding box of the light.  Thise boxes are not nececarry cubes
						//and may be smaller than the corresponding radius 
	float	brightness;
	qboolean visible;	//light is "visible" this frame
	qboolean shadowchainfilled;
	qboolean isStatic;	//light is static and has a precalc volume
	qboolean castShadow;//lights casts shadows
	qboolean halo;		//light has a halo
	mleaf_t	*leaf;		//leaf this light is in
	byte leafvis[MAX_MAP_LEAFS/8];//redone pvs for light, only poly's in nodes (leaf bits
	byte entclustervis[MAX_MAP_LEAFS/8];//original pvs a light origin (cluster bits)
	msurface_t	**visSurf; //the surfaces that should cast shadows for this light (only when static)
	int		*volumeCmds;  //gl commands to draw the shadow volume
	float	*volumeVerts;
	int		numVolumeVerts;
	lightcmd_t	*lightCmds;	//gl commands to draw the cap/lighted volumes
	int		numlightcmds;
	lightcmd_t	*lightCmdsMesh;	//gl commands to draw the cap/lighted volumes
	int		numlightcmdsmesh;
	int		 numVisSurf;
	int		style;
	entity_t *owner;
	screenrect_t scizz;
	int		filtercube;	//texture object of this light's cubemap filter
	vec3_t	angles; //angles of the cubemap filter
	float	rspeed; //rotation speed of cube map;
	float	cubescale; //scale factor of cube map;
	float	haloalpha; //alpha of halo
	int		area; //area (from areaportals) light is in
	shader_t *shader; //shader on this light
} shadowlight_t;

//PENTA: new
typedef struct aliaslightinstant_s {

	int lockframe;	//number of the frame when it was last locked.
	vec3_t lasteorg, lastlorg, lasteangles, lastvorg;
	float lastlradius;
	entity_t	*lastent;
	aliashdr_t * lasthdr;
	shadowlight_t *lastlight;
	vec3_t	lightpos, vieworg; //Object space light position
	void *lastframeinstant;

	//Per light stuff
	vec3_t	extvertices[MAXALIASVERTS]; //extruded vertices (volumes)
	vec3_t	tslights[MAXALIASVERTS]; //per vertex tangent space light vector
	vec3_t	tshalfangles[MAXALIASVERTS]; //per vertex half angle vector
	vec3_t	colors[MAXALIASVERTS]; //per vertex attenuation for non gf3 cards
	qboolean triangleVis[MAXALIASTRIS]; //triangle facingness for lights
	
	int		indecies[MAXALIASTRIS*3];//light visibility list
	int numtris;
	
} aliaslightinstant_t;

typedef struct aliasframeinstant_s {
	
     // chain of frameinstant for multiple surfaces
        struct aliasframeinstant_s *_next;
	
	int lockframe;	//number of the frame when it was last locked.
	int	updateframe; //number of the fame when it was last recalculated
	aliashdr_t *paliashdr;
	int lastpose1, lastpose2;
	float lastblend;
	entity_t	*lastent;
	qboolean lastshadowonly;
	aliashdr_t *lastpaliashdr;

	qboolean	shadowonly; //We only need the instant for shadow volume drawing
							//we use this for ents out of the frustum but e.g. behind the player
	//Per entity stuff
	vec3_t	vertices[MAXALIASVERTS]; //interpolated vertices
	vec3_t	normals[MAXALIASVERTS]; //interpolated vertex normals
	vec3_t	tangents[MAXALIASVERTS]; //interpolated vertex tangents
	vec3_t	binomials[MAXALIASVERTS]; //interpolated vertex binomials
	plane_t	triplanes[MAXALIASTRIS]; //triangle plane equatations

	aliaslightinstant_t *lightinstant;
} aliasframeinstant_t;

typedef struct brushlightinstant_s {

	int lockframe;	//number of the frame when it was last locked.
	vec3_t lasteorg, lastlorg, lasteangles, lastvorg;
	float lastlradius;
	entity_t	*lastent;
	shadowlight_t *lastlight;
	vec3_t	lightpos, vieworg; //Object space light position
	qboolean shadowonly, lastshadowonly;

	//Per light stuff
	vec3_t	extvertices[MAXALIASVERTS]; //extruded vertices (volumes)
	vec3_t	tslights[MAXALIASVERTS]; //per vertex tangent space light vector
	vec3_t	tshalfangles[MAXALIASVERTS]; //per vertex half angle vector
	float	atencoords[MAXALIASVERTS][2]; //per vertex attenuation texture coords for non gf3 cards
	float	colorscales[MAXALIASVERTS]; //per vertex attenuation texture coords for non gf3 cards
	qboolean polygonVis[MAXALIASTRIS]; //polygon facingness for lights
	qboolean neighbourVis[MAXALIASTRIS]; //polygon facingness for lights
} brushlightinstant_t;



#define	MAXSHADOWLIGHTS	256 //Maximum number of (client side) lights in a map
#define MAX_VOLUME_VERTICES 10000 //should be multiple of 4 because this is used as a vertex array
								 //with GL_QUADS
#define MAXUSEDSHADOWLIGHS 64 //Maximum number of lights that can be used in a single frame

extern int numShadowLights;	//number of lights currently on client
extern int numStaticShadowLights; //number of static lights on client
extern int numUsedShadowLights;
extern shadowlight_t shadowlights[MAXSHADOWLIGHTS];
extern shadowlight_t *usedshadowlights[MAXUSEDSHADOWLIGHS];
extern shadowlight_t *currentshadowlight;
extern msurface_t *shadowchain; //linked list of polygons that are shadowed
extern float frustumPlanes[6][4];

extern mmvertex_t *tempVertices;

#define	MAX_LIGHTMAPS	256
#define MAX_VOLUME_COMMANDS 131072 //Thats 0.5 meg storage for commands, insane
#define MAX_VOLUME_VERTS 87381 //1 Meg storage for vertices
#define MAX_LIGHT_COMMANDS 65536 //0.25 meg for light commands
extern lightcmd_t	lightCmdsBuff[MAX_LIGHT_COMMANDS+128];

//XYZ
extern int	numNormals[MAXALIASTRIS]; //Used during tangent space calc
extern char	loadname[32];	// for hunk tags

//view origin in object space
extern vec3_t object_vieworg;
extern vec3_t tsLightVects[MAXALIASTRIS*3];
extern vec3_t tsHalfAngles[MAXALIASTRIS*3];

//PENTA: Shadow bsp's

typedef struct svnode_s {
	plane_t			*splitplane;
	struct svnode_s	*children[2];
} svnode_t;

extern int svBsp_NumCutPolys;
extern int svBsp_NumKeptPolys;
extern int svBsp_NumAddedPolys;
extern int svBsp_NumMissedPlanes;
extern int svBsp_NumMissedNodes;
extern int numClearsSaved;

extern int planesusedpool;
extern int nodesusedpool;

extern int aliasCacheRequests, aliasFullCacheHits, aliasPartialCacheHits;	// <AWE> added "extern".
extern int brushCacheRequests, brushFullCacheHits, brushPartialCacheHits;	// <AWE> added "extern".

//Don't cast shadows with this light
#define PFLAG_NOSHADOW 1
//Draw a halo around the light
#define PFLAG_HALO 2
/*
	It seems in c you can only return structs when you prototype them first
	well I don't now for sure since I'm actually not c a specialist.
	If you know the answer mail me please.
*/

svnode_t *R_CreateEmptyTree(void);
svnode_t *R_AddShadowCaster(svnode_t *node, vec3_t *v, int vnum, msurface_t *surf,int depth);
svnode_t *ExpandVolume(vec3_t *v,int *sign, int vnum, msurface_t *surf);
plane_t *AllocPlane(plane_t *tryplane);
svnode_t *AllocNode(void);
svnode_t *NodeFromEdge(vec3_t *v,int vnum, int edgeindex);
float CalcFov (float fov_x, float width, float height);

/* other c twists (i'm pascal-core and java-used)*/
// <AWE> added misc function prototypes, fixed functions without return type.
void		Mod_LoadMd3Model (model_t *mod, void *buffer);
void		R_AddRectList (screenrect_t *rec);
void		R_AllocateMirror (msurface_t *surf);
void		R_AnimateLight (void);
void		R_AutomaticLightPos (void);
void		R_StaticLightFromEnt (entity_t *ent);
qboolean	R_CheckRectList (screenrect_t *rec);
void		R_ClearBrushInstantCaches (void);
void		R_ClearInstantCaches (void);
void		R_ClearParticles (void);
void		R_ClearDecals(void);
void		R_ClearRectList (void);
void		R_ConstructShadowVolume (shadowlight_t *light);
qboolean	R_ContributeFrame (shadowlight_t *light);
qboolean	R_CullBox (vec3_t mins, vec3_t maxs);
void		R_DrawAliasBumped (aliashdr_t *paliashdr, aliasframeinstant_t *instant);
void		R_DrawAliasBumpedGF3 (aliashdr_t *paliashdr, aliasframeinstant_t *instant);
void		R_DrawAliasBumpedRadeon(aliashdr_t *paliashdr, aliasframeinstant_t *instant);//PA:
void		R_DrawBrushBumpedRadeon(entity_t *e);//PA:
void		R_DrawAliasBumpedParhelia(aliashdr_t *paliashdr, aliasframeinstant_t *instant);//PA:
void		R_DrawBrushBumpedParhelia(entity_t *e);//PA:
void		R_DrawAliasBumpedARB(aliashdr_t *paliashdr, aliasframeinstant_t *instant);//PA:
void		R_DrawBrushBumpedARB(entity_t *e);//PA:
void		R_DrawAliasFrameWV (aliashdr_t *paliashdr, aliasframeinstant_t *instant, qboolean specular);
void		R_DrawAliasObjectLight (entity_t *e, void (*AliasGeoSender) (aliashdr_t *paliashdr,
                                                                             aliasframeinstant_t* instant));
void		R_DrawBrushATT (entity_t *ent);
void		R_DrawBrushBumped (entity_t *e);
void		R_DrawBrushBumpedGF3 (entity_t *e);
void		R_DrawBrushBumpedRadeon (entity_t *e);
void		R_DrawBrushBumpedParhelia (entity_t *e);
void		R_DrawBrushBumpedARB (entity_t *e);
void		R_DrawBrushModel (entity_t *e);
void		R_DrawBrushModelVolumes(entity_t *e);
void		R_DrawBrushObjectLight (entity_t *e,void (*BrushGeoSender) (entity_t *e));
void		R_DrawBrushWV (entity_t *e, qboolean specular);
void		R_DrawGlare (void);
void		R_DrawLightEntities (shadowlight_t *l);
void		R_DrawParticles (void);
void		R_DrawDecals (void);
void		R_DrawShadowVolume (shadowlight_t *light);
void		R_DrawSkyChain (msurface_t *s);
void		R_DrawSpriteModelWV (entity_t *e);
void		R_DrawWaterSurfaces (void);
void		R_DrawWorldBumped (/* shadowlight_t *l */);
void		R_DrawWorldBumpedGEN (void);
void 		R_DrawWorldBumpedGF (void);
void		R_DrawWorldBumpedGF3 (void);
void		R_DrawWorldBumpedRadeon (void);
void		R_DrawWorldBumpedParhelia (void);
void		R_DrawWorldBumpedARB (void);
void		R_DrawWorldWV (lightcmd_t *lightCmds, qboolean specular);
qboolean	R_FillLightChains (shadowlight_t *light);
mspriteframe_t *R_GetSpriteFrame (entity_t *currententity);
void		R_Glare (void);
void		R_InitDrawWorld (void);
void		R_InitGlare (void);
void		R_InitMirrorChains (void);
void		R_InitParticles (void);
void		R_InitDecals (void);
void		R_InitShadowsForFrame (void);
int		R_LightPoint (vec3_t p);
void		R_LoadVertexProgram (void);
void		R_NewMirrorChains (void);
void		R_ParticleGunHits (vec3_t org, int type);
void		R_RenderGlow (shadowlight_t *light);
void		R_RenderScene (void);
void		R_RotateForEntity (entity_t *e);
void		R_SetTotalRect (void);
void		R_SetupBrushInstantForLight(entity_t *e);
void		R_SetupInstantForLight(entity_t *e);
void		R_SetupInstantForFrame(entity_t *e, qboolean forcevis);
void		R_SetupInstants (void);
qboolean	R_ShouldDrawViewModel (void);
void		R_StoreEfrags (efrag_t **ppefrag);
void		R_FillEntityLeafs (entity_t *ent);
void		R_WorldMultiplyTextures (void);
void		R_WorldToObjectMatrix(entity_t *e, matrix_4x4 result);

/**
	Returns true if both boxes intersect
*/
aabox_t emptyBox (void);
aabox_t constructBox (vec3_t mins, vec3_t maxs);
qboolean intersectsBox(aabox_t *b1, aabox_t *b2);
aabox_t intersectBoxes(aabox_t *b1, aabox_t *b2);
aabox_t addBoxes(aabox_t *b1, aabox_t *b2);

int		EasyTgaLoad (char *filename);
void		EmitBothSkyLayers (msurface_t *fa);
void		EmitMirrorPolys (msurface_t *fa);
void		EmitMirrorWaterPolys (msurface_t *fa);
void		EmitSkyPolys (msurface_t *fa);
void		EmitWaterPolys (msurface_t *fa);
//void		InitShaderTex (void);
void 		LoadColorTGA (FILE *fin, byte *pixels, int *width, int *height);
void		LoadGrayTGA (FILE *fin,byte *pixels,int *width, int *height);
int             LoadTextureInPlace(char* filename, int size, byte* mem, int* width, int* height);
void            LoadTGA (FILE *fin);
//qboolean	OverrideFluidTex (char *name);
void		ProjectPlane (const vec3_t src,const vec3_t v1,const vec3_t v2,vec3_t dst);
void		TraceLine (vec3_t start, vec3_t end, vec3_t impact);

void		GL_AddColor (void);
void		GL_BuildLightmaps (void);
void		GL_DisableColorShader (qboolean specular);
void 		GL_DrawAlpha (void);
void		GL_EnableColorShader (qboolean specular);
void		GL_GetOverrideName (char *identifier, char *tail, char *dest);
int		GL_LoadCubeMap (int identifier);
void		GL_MakeAliasModelDisplayLists (model_t *m, aliashdr_t *hdr);
void		R_DrawAliasModel ( float bright);
void		GL_ModulateAlphaDrawColor (void);
void		GL_SelectTexture (GLenum target);
void		GL_Set2D (void);
void		GL_SetupCubeMapMatrix (const transform_t *tr);
//void		GL_SubdivideSurface (msurface_t *fa);
void		R_DrawCaustics(void);
int			CL_PointContents (vec3_t p);
void		V_CalcBlend (void);

#define VERTEX_TEXTURE 1
#define VERTEX_LIGHTMAP 2

int R_GetNextVertexIndex(void);
int R_AllocateVertexInTemp(vec3_t pos, float texture [2], float lightmap[2], byte color[4]);
void R_CopyVerticesToHunk(void);

typedef struct mirrorplane_s {
	int texture_object;  //Object we should render to and use for drawing
	int	lockframe, updateframe;		//Index of frame when it was last updated
	mplane_t	plane;		//Plane equatation of mirror face
	msurface_t *chain;	//Chain of mirror poly's
	float	matrix[16];
} mirrorplane_t;

#define NUM_MIRROR_PLANES 8
extern mirrorplane_t mirrorplanes[NUM_MIRROR_PLANES];
extern int mirror_contents;
extern int newenvmap;

msurface_t	*causticschain;
extern int	caustics_textures[8];
extern qboolean	busy_caustics;

extern char	skybox_name[64];
extern float skybox_cloudspeed;
extern qboolean skybox_hasclouds;

extern qboolean is_q3map;

void CS_Create(dq3face_t *in, mesh_t *mesh, mapshader_t *shader);
//void CS_DrawAmbient(mcurve_t *curve);
void CS_FillBinomials(void);

extern int lightmap_textures;

#include "gl_md3.h"
#include "bumpdriver.h"
#include "gl_drivermem.h"
//*******************************
//  Shader related declarations
//*******************************
//

extern vertexdef_t worldVertexDef;

#include "surfaceflags.h"

void Draw_TextureMode_f (void);

extern cvar_t gl_max_size;
extern cvar_t gl_picmip;
extern cvar_t gl_gloss;
extern cvar_t gl_compress_textures;
extern cvar_t willi_gray_colormaps;

gltexture_t *GL_CacheTexture (char *filename,  qboolean mipmap, int type);
shader_t *GL_ShaderForName(const char *name);
qboolean IsShaderBlended(shader_t *s);
void SH_SetupTcMods(stage_t *s);
void SH_SetupSimpleStage(stage_t *s);
void SH_BindBumpmap(shader_t *shader, int index);
void SH_BindColormap(shader_t *shader, int index);
void SH_SetupAlphaTest(shader_t *shader);

void Roq_Info_f(void);
void Roq_SetupTexture(gltexture_t *tex,char *filename);
void Roq_FreeTexture(gltexture_t *tex);
void Roq_UpdateTexture(gltexture_t *tex);

#define FILE_LIGHTMAP_WIDTH 128
#define PACKED_LIGHTMAP_WIDTH 512
#define PACKED_LIGHTMAP_COLUMS (PACKED_LIGHTMAP_WIDTH/FILE_LIGHTMAP_WIDTH)
#define PACKED_LIGHTMAP_COUNT (PACKED_LIGHTMAP_COLUMS*PACKED_LIGHTMAP_COLUMS)

#define LIGHTMAP_COLUMN(r) (((r)%PACKED_LIGHTMAP_COUNT)%PACKED_LIGHTMAP_COLUMS)
#define LIGHTMAP_ROW(r) (((r)%PACKED_LIGHTMAP_COUNT)/PACKED_LIGHTMAP_COLUMS)
